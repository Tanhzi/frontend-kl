import React, { useEffect, useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import './Frame.css';

function Frame() {
  const location = useLocation();
  const navigate = useNavigate();

  // Nhận dữ liệu truyền qua state từ trang trước (compositeImage, size, cut)
  const { photos, compositeImage, frameType, size, cut } = location.state || {};
  const id_admin = localStorage.getItem('id_admin');
  const id_topic = localStorage.getItem('id_topic');

  // State lưu danh sách các khung ảnh được lấy từ PHP
  const [framesList, setFramesList] = useState([]);
  // State chỉ số khung ảnh đang được chọn
  const [currentFrameIndex, setCurrentFrameIndex] = useState(0);
  // State chứa ảnh preview đã được composite theo tỷ lệ đúng
  const [previewImage, setPreviewImage] = useState(null);
  // State lưu loại khung ảnh đang được chọn
  const [selectedType, setSelectedType] = useState('all');

  // State lưu danh sách các loại khung ảnh
  const [frameTypes, setFrameTypes] = useState(['all']);

  // Gọi PHP để lấy danh sách các khung ảnh dựa trên id_admin, id_topic và cut
  useEffect(() => {
    if (id_topic && cut) {
      async function fetchFrames() {
        try {
          const response = await fetch(
            `${import.meta.env.VITE_API_BASE_URL}/get_frame.php?id_admin=${id_admin}&id_topic=${id_topic}&cuts=${cut}`
          );
          const result = await response.json();
          if (result.status === 'success') {
            // Đảm bảo mỗi frame có type hợp lệ
            const processedFrames = result.data.map(frame => ({
              ...frame,
              type: frame.type || 'default' // Nếu type là null hoặc undefined, gán giá trị mặc định
            }));
            setFramesList(processedFrames);
            // Cập nhật frameTypes dựa trên dữ liệu từ API
            const types = ['all', ...new Set(processedFrames.map(frame => frame.type))];
            setFrameTypes(types);
            setCurrentFrameIndex(0);
          } else {
            console.error("Error fetching frames:", result.message);
          }
        } catch (error) {
          console.error("Error fetching frames:", error);
        }
      }
      fetchFrames();
    }
  }, [id_admin, id_topic, cut]);

  // Lọc frames theo type đã chọn
  const filteredFrames = selectedType === 'all' 
    ? framesList 
    : framesList.filter(frame => frame.type === selectedType);

  // Cập nhật currentFrameIndex khi chuyển tab
  useEffect(() => {
    setCurrentFrameIndex(0);
  }, [selectedType]);

  // Hàm hỗ trợ load ảnh từ URL, trả về Promise khi ảnh được tải
  const loadImage = (src) => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'Anonymous';
      img.onload = () => resolve(img);
      img.onerror = (err) => reject(err);
      img.src = src;
    });
  };

  // Hàm tạo preview image từ compositeImage và overlay khung ảnh
  const createPreviewImage = async () => {
    if (!compositeImage || filteredFrames.length === 0) return;
    try {
      const baseImg = await loadImage(compositeImage);
      const selectedFrame = filteredFrames[currentFrameIndex].frame;
      const overlaySrc = `data:image/*;base64,${selectedFrame}`;
      const frameImg = await loadImage(overlaySrc);

      let canvasWidth, canvasHeight;
      if (cut === "41") {
        canvasWidth = 1200; // Total width for both sides
        canvasHeight = 1800;
      } else if (cut === "42,6") {
        canvasWidth = 1200;
        canvasHeight = 1800;
      } else if (cut === "3") {
        canvasWidth = 1800;
        canvasHeight = 600;
      } else {
        canvasWidth = size?.width || baseImg.width;
        canvasHeight = size?.height || baseImg.height;
      }
  
      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext('2d');
  
      // Vẽ ảnh      
      if (cut === "41") {
        // Draw the original image on the left side
        ctx.drawImage(baseImg, 0, 0, 600, 1800);
        // Draw the same image again on the right side
        ctx.drawImage(baseImg, 600, 0, 600, 1800);
      } else {
        ctx.drawImage(baseImg, 0, 0, canvasWidth, canvasHeight);
      }
      
      ctx.drawImage(frameImg, 0, 0, canvasWidth, canvasHeight);

      const previewDataURL = canvas.toDataURL('image/png');
      setPreviewImage(previewDataURL);
    } catch (error) {
      console.error("Error creating preview image:", error);
    }
  };

  // Khi compositeImage, framesList hoặc currentFrameIndex thay đổi, cập nhật preview
  useEffect(() => {
    createPreviewImage();
  }, [compositeImage, filteredFrames, currentFrameIndex, cut, size]);

  // Countdown và tự chuyển sang trang Qr
  const [countdown, setCountdown] = useState(100);
  const [autoTriggered, setAutoTriggered] = useState(false);
  useEffect(() => {
    if (countdown <= 0) return;
    const timer = setInterval(() => {
      setCountdown(prev => prev - 1);
    }, 1000);
    return () => clearInterval(timer);
  }, [countdown]);
  useEffect(() => {
    if (countdown === 0 && !autoTriggered) {
      setAutoTriggered(true);
      handleContinue();
    }
  }, [countdown, autoTriggered]);

  // Hàm xử lý khi bấm "TIẾP TỤC" hoặc khi countdown về 0:
  // Kết hợp ảnh composite với overlay khung ảnh và chuyển sang trang Qr
  const handleContinue = async () => {
    if (!compositeImage) return;
    try {
      const baseImg = await loadImage(compositeImage);
      if (filteredFrames.length === 0) {
        console.error("No frame overlay available");
        return;
      }
      const selectedFrame = filteredFrames[currentFrameIndex].frame;
      const overlaySrc = `data:image/*;base64,${selectedFrame}`;
      const frameImg = await loadImage(overlaySrc);
  
      let canvasWidth, canvasHeight;
      if (cut === "41") {
        canvasWidth = 1200; // Total width for both sides
        canvasHeight = 1800;
      } else if (cut === "42,6") {
        canvasWidth = 1200;
        canvasHeight = 1800;
      } else if (cut === "3") {
        canvasWidth = 1800;
        canvasHeight = 600;
      } else {
        canvasWidth = size?.width || baseImg.width;
        canvasHeight = size?.height || baseImg.height;
      }
  
      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext('2d');
  
      // Vẽ ảnh      
      if (cut === "41") {
        // Draw the original image on the left side
        ctx.drawImage(baseImg, 0, 0, 600, 1800);
        // Draw the same image again on the right side
        ctx.drawImage(baseImg, 600, 0, 600, 1800);
      } else {
        ctx.drawImage(baseImg, 0, 0, canvasWidth, canvasHeight);
      }
      
      ctx.drawImage(frameImg, 0, 0, canvasWidth, canvasHeight);
  
      // Lấy final image trực tiếp từ canvas chính (không cần canvas phụ nữa)
      const finalImage = canvas.toDataURL('image/png');
      
      navigate('/Qr', { 
        state: { 
          photos, 
          finalImage, 
          size,
          cut
        } 
      });
    } catch (error) {
      console.error("Error processing image:", error);
    }
  };

  // Các hàm xử lý chuyển khung ảnh bằng nút trái/phải
  const handlePrevFrame = () => {
    setCurrentFrameIndex(prev => prev === 0 ? framesList.length - 1 : prev - 1);
  };

  const handleNextFrame = () => {
    setCurrentFrameIndex(prev => prev === framesList.length - 1 ? 0 : prev + 1);
  };

  return (
    <div className="frame-container">
      {/* Countdown ở góc trên bên trái */}
      <div style={{
        position: 'absolute',
        top: '10px',
        left: '10px',
        fontSize: '20px',
        fontWeight: 'bold',
        color: 'rgb(247, 107, 187)',
        padding: '5px',
        borderRadius: '5px',
        zIndex: 1000
      }}>
        ⌛: {countdown}
      </div>

      <h2 className="touch-to-crecuts pt-5">VUI LÒNG CHỌN KHUNG ẢNH BẠN MUỐN IN</h2>

      <div className="frame-content pt-5">
        {/* Cột bên trái: hiển thị ảnh composite (preview) */}
        <div className="col-left">
  {previewImage ? (
    <div className="image-wrapper">
      <img
        src={previewImage}
        alt="Preview Composite"
        className={`composite-image ${cut === "41" ? "composite-image--cut41" : ""}`}
      />
    </div>
  ) : (
    <div className="no-image">Chưa có ảnh</div>
  )}
</div>


        {/* Cột bên phải: carousel thumbnail của các khung ảnh */}
        <div className="col-right">

          {/* Frame type tabs */}
          <div className="frame-tabs">
            {frameTypes && frameTypes.map((type) => (
              <button
                key={type}
                className={`tab ${selectedType === type ? 'active' : ''}`}
                onClick={() => setSelectedType(type)}
              >
                {type === 'all' ? 'TẤT CẢ' : (type || 'DEFAULT').toUpperCase()}
              </button>
            ))}
          </div>

          <div className="frame-thumbnails">
            <div className="thumbnails-wrapper">
              {filteredFrames.map((frameObj, index) => (
                <img 
                  key={index}
                  src={`data:image/*;base64,${frameObj.frame}`}
                  alt={`Frame ${index + 1}`}
                  className={`thumbnail ${index === currentFrameIndex ? 'selected' : ''}`}
                  onClick={() => setCurrentFrameIndex(index)}
                />
              ))}
            </div>
          </div>
        </div>
      </div>

      <div className="frame-footer">
        <button className="continue-btn" onClick={handleContinue}>TIẾP TỤC</button>
      </div>
    </div>
  );
}

export default Frame;